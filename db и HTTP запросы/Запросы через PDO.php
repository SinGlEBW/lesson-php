<?
/*#######---Класс для работы с бд---#######*/

$options = [
	// PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,
  PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_OBJ//чтоб по 100 раз не писать в query 2м параметром, укажем сразу в опциях
  PDO::ATTR_STRINGIFY_FETCHES => false,//Написано что числовые значения не будет преобразовывать в строку, но по факту ATTR_EMULATE_PREPARES
	PDO::ATTR_EMULATE_PREPARES => false//выполняет функцию ATTR_STRINGIFY_FETCHES, хотя описание другое
];

$PDO = new PDO("mysql:host=localhost;dbname=test_bd;","root","",$options);//$db  - это объект PDO со своими методами
/* 
  Проверить методы get_class_methods($db)

  Передавать данные от клиента лучше через подготовленный запрос - prepare, execute, а через query доставать из бд
  Оба отправляют сразу запрос. 
  Данные из бд это объект PDOStatement
*/
$PDO->query("INSERT INTO users(name) VALUE ('Вася')");//следить за " '. Вернёт объект PDOStatement с методами и свойством queryString || false
$PDO->exec("UPDATE users SET name=REPLACE=(name, 'Толя', 'Вася')");//вернёт кол-во затронутых строк || false

//Пример подготовленного запроса. prepare данные от клиента обработает сама
$sql = $PDO->prepare('INSERT INTO users(pass) VALUES(:pass)');//в таблицу users колонку pass
$sql->execute(["pass" => $pass]);//отправляет подготовленный запрос.вернёт true если всё ок, если есть чт вернуть то PDOStatement. || false
/*
  Значение :pass это Именованный placeholder. Можно указать знак ?, тогда в execute нужно придерживаться правильного
  порядка передачи значений. Пример users(name, pass, city) VALUES(?,?,?)  execute([$name, $pass, $city])
*/
//контроль объекта PDO
$db->beginTransaction();//отключает автоматический запрос методов query, exec и даже (prepare с execute не смотря на то что execute возвращают true)
$db->inTransaction();//проверяет включён ли включён ли ручной режим транзакции ( то есть пары beginTransaction и commit)
$db->lastInsertId();/*показывает id транзакции. Пример запрос разрешён через commit, возвращает его id, если не разрешён, так же возвращает id но следующей строки.
                      Так можно 10 раз не пропустить запрос, а потом положить результат и будет разрыв id. Ложили с 10 id потом с 20 будет*/
/* тут запрос  */
$db->commit();//Запрос этих методов будет отправлен(разрешён) только после вызова commit()

//$PDO
->beginTransaction();// Инициализация транзакции
->commit();// Фиксирует транзакцию
->__construct();// Создает экземпляр PDO, предоставляющий соединение с базой данных
->errorCode();// Возвращает код SQLSTATE результата последней операции с базой данных
->errorInfo();// Получает расширенную информацию об ошибке, произошедшей в ходе последнего обращения к базе данных
->exec();// Выполняет SQL-запрос и возвращает количество затронутых строк
->getAttribute();// Получить атрибут соединения с базой данных
->getAvailableDrivers();// Возвращает массив доступных драйверов PDO
->inTransaction();// Проверяет, начата ли транзакция
->lastInsertId();// Возвращает ID последней вставленной строки или значение последовательности
->prepare();// Подготавливает запрос к выполнению и возвращает связанный с этим запросом объект
->query();// Выполняет SQL-запрос и возвращает результирующий набор в виде объекта PDOStatement
->quote();// Заключает строку в кавычки для использования в запросе
->rollBack();// Откат транзакции
->setAttribute();// Установка атрибута

//Запросы возвращают объект PDOStatement. Его методы
->bindColumn()// — Связывает столбец с переменной PHP
->bindParam()// — Привязывает параметр запроса к переменной
->bindValue()// — Связывает параметр с заданным значением
->closeCursor()// — закроет соединение с бд для следующего запроса
->columnCount()// — Возвращает количество столбцов в результирующем наборе
->debugDumpParams()// — Вывод информации о подготовленной SQL-команде в целях отладки
->errorCode()// — Получает код SQLSTATE, связанный с последней операцией в объекте PDOStatement
->errorInfo()// — Получение расширенной информации об ошибке, произошедшей в результате работы объекта PDOStatement
->execute()// — Запускает подготовленный запрос на выполнение
->fetch()// — Извлечение следующей строки из результирующего набора
->fetchAll()// — Возвращает массив, содержащий все строки результирующего набора
->fetchColumn()// — Возвращает данные одного столбца следующей строки результирующего набора
->fetchObject()// — Извлекает следующую строку и возвращает ее в виде объекта
->getAttribute()// — Получение значения атрибута запроса PDOStatement
->getColumnMeta()// — Возвращает метаданные столбца в результирующей таблице
->nextRowset()// — Переход к следующему набору строк в результате запроса
->rowCount()// — Возвращает количество строк, затронутых последним SQL-запросом
->setAttribute()// — Устанавливает атрибут объекту PDOStatement
->setFetchMode()// — Устанавливает режим выборки по умолчанию для объекта запроса









?>

